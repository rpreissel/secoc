#!/usr/bin/env bash

# seccode - OpenCode AI Podman Runner with Auto-Update
# Unified script for build and run with automatic version management
set -eo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

IMAGE_NAME="opencode-ai"
IMAGE_TAG="latest"
FULL_IMAGE_NAME="${IMAGE_NAME}:${IMAGE_TAG}"
CONTAINER_NAME="opencode-ai-$(date +%s)"

# Determine script directory (where this script is located)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Dockerfile directory (where the Dockerfile is located)
DOCKERFILE_DIR="${SCRIPT_DIR}"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

validate_opencode_args() {
    local opencode_args=("$@")
    local arg
    for arg in "${opencode_args[@]}"; do
        # Block dangerous patterns that could lead to command injection
        if [[ "${arg}" =~ \$ ]] || [[ "${arg}" =~ \; ]] || [[ "${arg}" =~ \& ]] || \
           [[ "${arg}" =~ \| ]] || [[ "${arg}" =~ \< ]] || [[ "${arg}" =~ \> ]]; then
            print_error "Invalid argument detected: ${arg}"
            print_error "Arguments may not contain: $ ; & | < >"
            exit 1
        fi
    done
}

print_header() {
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}" >&2
}

print_info() {
    echo -e "${BLUE}ℹ $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}" >&2
}

print_error() {
    echo -e "${RED}✗ $1${NC}" >&2
}

show_help() {
    cat <<EOF
${BLUE}seccode${NC} - OpenCode AI Container Runner with Auto-Update

${CYAN}USAGE:${NC}
  seccode [OPTIONS] [WORKSPACE] [OPENCODE_ARGS...]

${CYAN}OPTIONS:${NC}
  --rebuild              Force image rebuild (ignore version check)
  --no-update            Skip auto-update (use existing image)
  --version VERSION      Use specific OpenCode version (e.g. 0.5.0)
  --help                 Show this help

${CYAN}ARGUMENTS:${NC}
  WORKSPACE             Path to workspace directory (default: current directory)
  OPENCODE_ARGS         All additional parameters are passed to OpenCode

${CYAN}EXAMPLES:${NC}
  seccode                                    # Start in current directory
  seccode /path/to/project                   # Start with specific workspace
  seccode --model claude-sonnet-4            # With OpenCode parameters
  seccode /path/to/project --model gpt-4     # Workspace + parameters
  seccode --rebuild                          # Force rebuild
  seccode --version 0.5.0                    # Use specific version
  seccode --no-update                        # Skip update check

${CYAN}INSTALLATION FOR GLOBAL ACCESS:${NC}
  # Create symlink in /usr/local/bin (callable from anywhere)
  sudo ln -s ${SCRIPT_DIR}/seccode /usr/local/bin/seccode
  
  # Or in ~/.local/bin (without sudo, add ~/.local/bin to \$PATH)
  mkdir -p ~/.local/bin
  ln -s ${SCRIPT_DIR}/seccode ~/.local/bin/seccode
  export PATH="\$HOME/.local/bin:\$PATH"  # In ~/.bashrc or ~/.zshrc

${CYAN}FEATURES:${NC}
  - Automatic update check on every start
  - Automatic build on new version or missing image
  - Persistent configuration and caches
  - Git and SSH integration
  - Build tool cache support (Maven, Gradle, NPM, Pip, Bun)
  - Callable from anywhere (with symlink or directly)

${CYAN}SCRIPT INFO:${NC}
  Script Directory: ${SCRIPT_DIR}
  Dockerfile Directory: ${DOCKERFILE_DIR}

EOF
    exit 0
}

# ============================================================================
# VERSION MANAGEMENT
# ============================================================================

check_latest_version() {
    print_info "Determining latest OpenCode version..."
    
    local version=""
    local attempt=0
    local max_attempts=3
    
    while [ -z "${version}" ] && [ ${attempt} -lt ${max_attempts} ]; do
        version=$(curl -fsSL --connect-timeout 5 --max-time 10 \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/anomalyco/opencode/releases/latest" 2>/dev/null \
            | jq -r '.tag_name // empty' 2>/dev/null || echo "")
        attempt=$((attempt + 1))
        if [ -z "${version}" ] && [ ${attempt} -lt ${max_attempts} ]; then
            print_info "Retry ${attempt}/${max_attempts}..."
            sleep 2
        fi
    done
    
    # Remove 'v' prefix if present
    version="${version#v}"
    
    if [ -z "${version}" ]; then
        print_warning "Could not determine latest version, using 'latest'"
        echo "latest"
    else
        echo "${version}"
    fi
}

get_image_version() {
    if ! podman image exists "${FULL_IMAGE_NAME}" 2>/dev/null; then
        echo ""
        return
    fi
    
    local version
    version=$(podman inspect "${FULL_IMAGE_NAME}" --format '{{.Config.Labels.opencode_version}}' 2>/dev/null || echo "")
    echo "${version}"
}

needs_rebuild() {
    local force_rebuild=$1
    local skip_update=$2
    local target_version=$3
    
    # Force rebuild was requested
    if [ "${force_rebuild}" = "true" ]; then
        print_info "Rebuild was forced (--rebuild)"
        return 0
    fi
    
    # Skip update check
    if [ "${skip_update}" = "true" ]; then
        if podman image exists "${FULL_IMAGE_NAME}" 2>/dev/null; then
            print_info "Update check skipped (--no-update)"
            return 1
        else
            print_warning "Image does not exist, build required"
            return 0
        fi
    fi
    
    # Check if image exists
    if ! podman image exists "${FULL_IMAGE_NAME}" 2>/dev/null; then
        print_info "Image does not exist, build required"
        return 0
    fi
    
    # Get current image version
    local current_version
    current_version=$(get_image_version)
    
    if [ -z "${current_version}" ]; then
        print_warning "Could not determine image version, rebuild recommended"
        return 0
    fi
    
    # Compare with target version
    if [ "${current_version}" != "${target_version}" ]; then
        print_info "Version difference detected: ${current_version} → ${target_version}"
        return 0
    fi
    
    print_success "Image is up to date (Version: ${current_version})"
    return 1
}

# ============================================================================
# BUILD FUNCTIONS
# ============================================================================

build_image() {
    local opencode_version=$1
    local force_rebuild=$2
    
    print_header "OpenCode AI - Image Build"
    
    # Check if Dockerfile exists
    if [ ! -f "${DOCKERFILE_DIR}/Dockerfile" ]; then
        print_error "Dockerfile not found in: ${DOCKERFILE_DIR}"
        print_error "Please run the script from the project directory,"
        print_error "or create a symlink: sudo ln -s ${SCRIPT_DIR}/seccode /usr/local/bin/seccode"
        exit 1
    fi
    
    print_info "Building image: ${FULL_IMAGE_NAME}"
    print_info "OpenCode version: ${opencode_version}"
    print_info "Dockerfile directory: ${DOCKERFILE_DIR}"
    
    if [ "${force_rebuild}" = "true" ]; then
        print_warning "Rebuild mode: Build cache will be ignored"
    fi
    echo ""
    
    print_warning "⚠️  The build may take 5-10 minutes - Please be patient!"
    echo ""
    
    # Prepare build options
    local build_opts=(
        --tag "${FULL_IMAGE_NAME}"
        --format docker
        --build-arg OPENCODE_VERSION="${opencode_version}"
        --label opencode_version="${opencode_version}"
        --label build_date="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    )
    
    # Ignore cache on force_rebuild
    if [ "${force_rebuild}" = "true" ]; then
        build_opts+=(--no-cache)
    fi
    
    # Build image
    if podman build "${build_opts[@]}" "${DOCKERFILE_DIR}" ; then
        echo ""
        print_success "Image built successfully!"
        echo ""
    else
        echo ""
        print_error "Build failed!"
        exit 1
    fi
}

# ============================================================================
# RUN FUNCTIONS
# ============================================================================

setup_directories() {
    # OpenCode directories
    local opencode_config_dir="${HOME}/.config/opencode"
    local opencode_data_dir="${HOME}/.local/share/opencode"
    local opencode_state_dir="${HOME}/.local/state/opencode"
    local opencode_cache_dir="${HOME}/.cache/opencode"
    
    # Build tool caches
    local maven_cache_dir="${HOME}/.m2"
    local gradle_cache_dir="${HOME}/.gradle"
    local npm_cache_dir="${HOME}/.npm"
    local pip_cache_dir="${HOME}/.cache/pip"
    local bun_cache_dir="${HOME}/.cache/bun"
    
    # Create directories if they don't exist
    mkdir -p "${opencode_config_dir}"
    mkdir -p "${opencode_data_dir}"
    mkdir -p "${opencode_state_dir}"
    mkdir -p "${opencode_cache_dir}"
    mkdir -p "${maven_cache_dir}"
    mkdir -p "${gradle_cache_dir}"
    mkdir -p "${npm_cache_dir}"
    mkdir -p "${pip_cache_dir}"
    mkdir -p "${bun_cache_dir}"
    
    print_success "Config directory: ${opencode_config_dir}"
    print_success "Data directory: ${opencode_data_dir}"
    print_success "State directory: ${opencode_state_dir}"
    print_success "Cache directory: ${opencode_cache_dir}"
}

setup_volumes() {
    local workspace_dir=$1
    
    # OpenCode directories
    local opencode_config_dir="${HOME}/.config/opencode"
    local opencode_data_dir="${HOME}/.local/share/opencode"
    local opencode_state_dir="${HOME}/.local/state/opencode"
    local opencode_cache_dir="${HOME}/.cache/opencode"
    
    # Build tool caches
    local maven_cache_dir="${HOME}/.m2"
    local gradle_cache_dir="${HOME}/.gradle"
    local npm_cache_dir="${HOME}/.npm"
    local pip_cache_dir="${HOME}/.cache/pip"
    local bun_cache_dir="${HOME}/.cache/bun"
    
    # Git config
    local git_config_file="${HOME}/.gitconfig"
    local git_config_dir="${HOME}/.config/git"
    
    # SSH keys
    local ssh_dir="${HOME}/.ssh"
    
    # Use SELinux labeling only on Linux
    local selinux_label=""
    local selinux_label_ro=":ro"
    if [[ "$(uname -s)" == "Linux" ]]; then
        selinux_label=":Z"
        selinux_label_ro=":ro,Z"
    fi
    
    # Prepare volume options
    VOLUME_OPTS=(
        -v "${workspace_dir}:/home/opencode/workspace${selinux_label}"
        -v "${opencode_config_dir}:/home/opencode/.config/opencode${selinux_label}"
        -v "${opencode_data_dir}:/home/opencode/.local/share/opencode${selinux_label}"
        -v "${opencode_state_dir}:/home/opencode/.local/state/opencode${selinux_label}"
        -v "${opencode_cache_dir}:/home/opencode/.cache/opencode${selinux_label}"
        -v "${maven_cache_dir}:/home/opencode/.m2${selinux_label}"
        -v "${gradle_cache_dir}:/home/opencode/.gradle${selinux_label}"
        -v "${npm_cache_dir}:/home/opencode/.npm${selinux_label}"
        -v "${pip_cache_dir}:/home/opencode/.cache/pip${selinux_label}"
        -v "${bun_cache_dir}:/home/opencode/.cache/bun${selinux_label}"
    )
    
    # Mount git config if present
    if [ -f "${git_config_file}" ]; then
        VOLUME_OPTS+=(-v "${git_config_file}:/home/opencode/.gitconfig${selinux_label_ro}")
        print_success "Git config found: ${git_config_file}"
    else
        print_warning "Git config not found: ${git_config_file}"
    fi
    
    if [ -d "${git_config_dir}" ]; then
        VOLUME_OPTS+=(-v "${git_config_dir}:/home/opencode/.config/git${selinux_label_ro}")
        print_success "Git config dir found: ${git_config_dir}"
    fi
    
    # Mount SSH keys if present
    if [ -d "${ssh_dir}" ]; then
        VOLUME_OPTS+=(-v "${ssh_dir}:/home/opencode/.ssh${selinux_label_ro}")
        print_success "SSH keys found: ${ssh_dir}"
    else
        print_warning "SSH keys not found: ${ssh_dir}"
    fi
}

run_container() {
    local workspace_dir=$1
    shift
    local opencode_args=("$@")
    
    print_header "OpenCode AI - Container Start"
    
    setup_directories
    echo ""
    
    setup_volumes "${workspace_dir}"
    echo ""
    
    print_success "Workspace: ${workspace_dir}"
    echo ""
    
    print_info "Starting OpenCode container..."
    echo ""
    
    # Validate arguments for security
    validate_opencode_args "${opencode_args[@]}"
    
    # Start container
    podman run -it --rm \
        --name "${CONTAINER_NAME}" \
        --network host \
        --cap-add=NET_RAW \
        "${VOLUME_OPTS[@]}" \
        "${FULL_IMAGE_NAME}" ${opencode_args[@]+"${opencode_args[@]}"}
    
    local exit_code=$?
    
    echo ""
    if [ ${exit_code} -eq 0 ]; then
        print_success "Container terminated."
    else
        print_warning "Container terminated with exit code: ${exit_code}"
    fi
    
    return ${exit_code}
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Default values
    local force_rebuild=false
    local skip_update=false
    local opencode_version=""
    local workspace_dir=""
    local opencode_args=()
    
    # Parse parameters
    while [[ $# -gt 0 ]]; do
        case $1 in
            --rebuild)
                force_rebuild=true
                shift
                ;;
            --no-update)
                skip_update=true
                shift
                ;;
            --version)
                if [ -z "${2:-}" ]; then
                    print_error "--version requires a value"
                    exit 1
                fi
                opencode_version="$2"
                shift 2
                ;;
            --help|-h)
                show_help
                ;;
            *)
                # If workspace_dir not yet set and argument is a directory
                if [ -z "${workspace_dir}" ] && [ -d "$1" ]; then
                    workspace_dir="$1"
                    shift
                else
                    # All other parameters are OpenCode arguments
                    opencode_args+=("$1")
                    shift
                fi
                ;;
        esac
    done
    
    # Set workspace dir (default: current directory)
    if [ -z "${workspace_dir}" ]; then
        workspace_dir="."
    fi
    # Normalize and validate path
    workspace_dir="$(cd "${workspace_dir}" 2>/dev/null && pwd)"
    if [ -z "${workspace_dir}" ]; then
        print_error "Invalid workspace directory"
        exit 1
    fi
    
    print_header "seccode - OpenCode AI Runner"
    
    # Check if Podman is installed
    if ! command -v podman &> /dev/null; then
        print_error "Podman is not installed!"
        echo "Please install Podman: brew install podman"
        exit 1
    fi
    print_success "Podman found"
    echo ""
    
    # Determine OpenCode version if not specified
    if [ -z "${opencode_version}" ]; then
        opencode_version=$(check_latest_version)
    else
        print_info "Using specified OpenCode version: ${opencode_version}"
    fi
    
    if [ "${opencode_version}" != "latest" ]; then
        print_success "Target version: ${opencode_version}"
    fi
    echo ""
    
    # Check if build is needed
    if needs_rebuild "${force_rebuild}" "${skip_update}" "${opencode_version}"; then
        build_image "${opencode_version}" "${force_rebuild}"
    fi
    
    # Start container
    run_container "${workspace_dir}" "${opencode_args[@]+"${opencode_args[@]}"}"
}

# ============================================================================
# SCRIPT ENTRY POINT
# ============================================================================

main "$@"
